#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <sys/stat.h>
#include <limits.h>

#define SIZE 4096

/* a node on the linked list / tree */
typedef struct node {
    char letter;
    unsigned int frequency;
    struct node *next;
    struct node *left;
    struct node *right;
} node;

/* the body of the encoded file */
int *body;

/* the length of the body */
int body_length;

/* the head of the linked list */
node *head;

/* new tree nodes allocated for creating huffman tree */
node *new_tree_nodes[256];

/* nodes in the linked list */
node *nodes[256];

/* the root of the huffman tree */
node *root;

/* the file to write the output */
char *out_file;

/* the file descriptor for the output file */
int out_fd;

/* free the nodes */
void free_nodes() {
    int i;
    for(i = 0; i < 256;  i++) {
        free(nodes[i]);
    }
}

/* free the nodes generated by building the tree */
void free_tree_nodes() {
    int i;
    for (i = 0; i < 256; i++) {
        free(new_tree_nodes[i]);
    }
}

/* traverse the generated huffman tree */
void traverse_tree() {
    int i;
    int count;
    char buff[100];
    node *current_node = root;
    count = 0;

    /* if not stdout */
    if(out_fd != 1) {
        out_fd = open(out_file,
                      O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR);
    }

    if(out_fd == -1) {
        perror("out_file");
        exit(3);
    }
    for(i = 0; i <= body_length; i++) {
        /* leaf condition */
        if(current_node->left == NULL && current_node->right == NULL) {
            if(current_node->frequency != 0) {
                buff[count++] = current_node->letter;
                /* write 100 bytes at a time */
                if(count == 100) {
                    if(write(out_fd, buff, 100) == -1) {
                        perror("write");
                        exit(10);
                    }
                    count = 0;
                }
                current_node->frequency = current_node->frequency - 1;
            }
            /* reset traversal back to root */
            current_node = root;
        }
        if(body[i] == 0) {
            current_node = current_node->left;
        }
        else if(body[i] == 1) {
            current_node = current_node->right;
        }
    }
    if(write(out_fd, buff, count) == -1) {
        perror("write");
        exit(9);
    }
}

/* inserting in sorted order to linked list based on frequency */
void in_order_insert(node *n) {
    node *runner;
    if (head == NULL) {
        head = n;
        return;
    }
    if (n->frequency < head->frequency) {
        n->next = head;
        head = n;
        return;
    }

    runner = head;
    while (runner->next != NULL && n->frequency > runner->next->frequency) {
        runner = runner->next;
    }
    n->next = runner->next;
    runner->next = n;
}

/* build the huffman tree from the linked list */
void construct_tree(node *list_head) {
    int i;
    int node_sum;
    node *node_one;
    node *node_two;
    node *new_parent;
    node_one = list_head;
    i = 0;
    while (node_one->next != NULL) {
        node_two = node_one->next;
        head = node_two->next;
        node_sum = node_one->frequency + node_two->frequency;
        new_parent = (node *) malloc(sizeof(node));
        if(!new_parent) {
            perror("malloc");
            exit(2);
        }
        new_parent->frequency = node_sum;
        new_parent->left = node_one;
        new_parent->right = node_two;
        new_tree_nodes[i++] = new_parent;
        in_order_insert(new_parent);
        node_one->next = NULL;
        node_two->next = NULL;
        root = new_parent;
        node_one = head;
    }
}

/* multiplier for translating binary to decimal */
int calculate_multiplier(int pow) {
    int i;
    int result;
    result = 1;
    for(i = 0; i < pow; i++) {
        result *= 2;
    }
    return result;
}

/* parse the encoded file */
void parse_file(int fd) {
    char buff[SIZE];
    int num_unique_characters;
    int i;
    int j;
    int k;
    int node_place;
    int pow_count;
    int size_read;
    int new_size;
    node *runner;
    unsigned int decimal;
    int count;
    int single_char_write_count;

    if(read(fd, buff, 1) == -1) {
        perror("read");
        exit(8);
    }
    num_unique_characters = buff[0];

    /* either one letter or empty file */
    if(num_unique_characters == -1) {
        num_unique_characters = 0;
    }
    decimal = 0;
    runner = head;
    node_place = 0;
    for(i = 0; i < num_unique_characters + 1; i++) {
        /* establish a node for each character */
        node *new_node = malloc(sizeof(node));
        if(!new_node) {
            perror("malloc");
            exit(4);
        }
        nodes[node_place++] = new_node;
        if((read(fd, buff, 5)) == -1) {
            perror("read");
            exit(5);
        }
        new_node->letter = buff[0];
        pow_count = 0;
        /* iterate over the header and find the frequency of each letter */
        for(j = 1; j < 5; j++) {
            for(k = 0; k < 8; k++) {
                decimal += (((buff[j]>>k)&1) * calculate_multiplier(pow_count));
                pow_count++;
            }
        }
        new_node->frequency = decimal;
        if(i == 0) {
            head = new_node;
        } else {
            runner->next = new_node;
        }
        runner = new_node;
        /*printf("%d\n", decimal);*/
        decimal = 0;
        /* special case for one letter or empty file */
        if(num_unique_characters == 0) {
            new_size = SIZE;
            single_char_write_count = 0;
            for(i = 0; i < new_node->frequency; i++) {
                body = malloc(SIZE);
                if(!body) {
                    perror("malloc");
                    exit(17);
                }
                if(single_char_write_count == SIZE) {
                    new_size = new_size + SIZE;
                    body = realloc(body, new_size);
                    if(!body) {
                        perror("realloc");
                        exit(18);
                    }
                }
                body[i] = new_node->letter;
                single_char_write_count++;
            }
            write(out_fd, body, i);
            free(body);
            exit(0);
        }
    }

    /* iterate over the body of the file */
    body = malloc(SIZE);
    if(!body) {
        perror("malloc");
        exit(16);
    }
    body_length = 0;
    count = 0;
    new_size = SIZE;
    while((size_read = read(fd, buff, SIZE)) > 0) {
        for(i = 0; i < size_read; i++) {
            unsigned char this_byte  = buff[i];
            for(j = 7; j >= 0; j--) {
                if(count == SIZE) {
                    new_size = new_size + SIZE;
                    body = realloc(body, new_size);
                    if(!body) {
                        perror("realloc");
                        exit(6);
                    }
                    count = 0;
                }
                /* expose each bit in the body for tree traversal navigation */
                body[body_length] = (this_byte>>j)&1;
                body_length++;
                count+=sizeof(int);
            }
        }
    }
}

int main (int argc, char *argv[]) {
    int fd;

    if(argc > 3 || argc < 2) {
        printf("Usage: ./hdecode [ ( infile | - ) [ outfile ] ]\n");
        exit(1);
    }

    if(strcmp(argv[1], "-") == 0) {
        fd = 1;
    } else {
        fd = open(argv[1], O_RDONLY);
        if(fd == -1) {
            perror("open");
            exit(7);
        }
    }

    if(argc == 3) {
        out_file = argv[2];
    } else {
        out_fd = 1;
    }

    parse_file(fd);
    construct_tree(head);
    traverse_tree();
    free_tree_nodes();
    free_nodes();
    free(body);
    return(0);
}
